#!/bin/bash

SCRIPT="$0"

SSH_OPTIONS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o ConnectTimeout=5"
VMRUN_BIN='C:\Program Files (x86)\VMware\VMware Workstation\vmrun.exe'
VMPATH="$(cygpath -w "$(realpath ~/Documents/Virtual\ Machines)")"'\boot2docker\boot2docker.vmx'
VMDIR="$(dirname "$(cygpath "$VMPATH")")"
DOCKER_TLS_PORT=2376
DOCKER_USER_PASSWD=tcuser

function docker-host () {
    if [[ -n "${DOCKER_HOST}" ]]; then
        echo "${DOCKER_HOST}"
        return 0
    fi
    echo $(docker-ip)
}

function docker-ssh () {
    if [[ ! -t 0 || ! -t 1 ]]; then
        # pipe mode
        ssh ${SSH_OPTIONS} docker@$(docker-host) -- "$@"
    else
        # non pipe mode
        ssh ${SSH_OPTIONS} -t docker@$(docker-host) -- "$@"
    fi
}

function docker-ssh-batch-mode () {
    ssh ${SSH_OPTIONS} -o 'Batchmode yes' docker@$(docker-host) -- "$@"
}

function docker-escape-args () {
    if [[ $# == 0 ]]; then
        return
    fi
    args=( )
    for arg in "$@"; do
        args=("${args[@]}" $(printf '%q' "$arg"))
    done
    echo "${args[@]}"
}

# these 3 functions are because we don't have vmware shared folders yet
# http://blog.tutum.co/2014/11/05/how-to-use-docker-on-windows/
function docker-mount-cifs () {
    local LOCAL_FOLDER="$1"
    local LOCAL_FOLDER_CLEANNAME="$(echo "$LOCAL_FOLDER" | sed 's/\$$//')"
    local REMOTE_FOLDER="${2-/mnt/hgfs/$LOCAL_FOLDER_CLEANNAME}"
    local NAT_HOST="$(docker-host | sed 's/\.[0-9]\+$//').1"
    if [[ -z "$CIFS_PASSWORD" ]]; then
        echo -ne "\033[0;32mEnter CIFS share password: \033[0m"
        read -s -p "" CIFS_PASSWORD
        echo
    fi
    docker-ssh << DOCKER_MOUNT_SHARE
sudo mkdir -p "${REMOTE_FOLDER}";
sudo mount -tcifs "-ousername=${USER},password=${CIFS_PASSWORD},rw,nounix,iocharset=utf8,file_mode=0777,dir_mode=0777" \
    "//${NAT_HOST}/${LOCAL_FOLDER}" "${REMOTE_FOLDER}"
DOCKER_MOUNT_SHARE
}

docker-ls-admin-shares () {
    net share | tr -d '\r' | grep 'Default share' | cut -d ' ' -f1 | tr '[:upper:]' '[:lower:]'
}

docker-mount-all-admin-shares () {
    # only mount when cifs is installed
    if ! docker-ssh 'type mount.cifs &>/dev/null'; then
        return 1
    fi

    for share in $(docker-ls-admin-shares | tr '\n' ' '); do
        docker-mount-cifs "$share"
    done
}

# list things that should have been shared...
function docker-vm-list-shares () {
    local vm_shares="$(cat "$(cygpath "$VMPATH")" | grep sharedFolder | grep 'hostPath\|guestName' | tr -d '\r')"
    local vm_shares_idx="$(echo "${vm_shares}" | cut -d'.' -f1 | sort | uniq)"
    local idx
    local fol mnt

    local IFS=$'\n'
    for idx in "${vm_shares_idx}"; do
        fol="$(cygpath -u "$(echo "${vm_shares}" | grep "^${idx}.hostPath" | sed 's#^'${idx}'.hostPath = "\(.\+\)"$#\1#')")"
        mnt="/mnt/hgfs/$(echo "${vm_shares}" | grep "^${idx}.guestName" | sed 's#^'${idx}'.guestName = "\(.\+\)"$#\1#')"
        echo "${fol}:${mnt}"
    done
    unset IFS
}

function docker-get-mapped-share-name () {
    local cwd="$(realpath "$1")"
    local IFS=$'\n'
    local map dir
    # see if we're in a mapped path
    for map in "$(docker-vm-list-shares)"; do
        dir="$(echo "${map}" | cut -d':' -f1)"
        if [[ "${cwd}" =~ ^"${dir}" ]]; then
            echo "$(echo "${map}" | cut -d':' -f2)/$(echo "$cwd" | sed "s!^${dir}/!!")"
            return 0
        fi
    done
    unset IFS
    return 1
}

function docker-refresh-port-forwards () {
    curl -q -m 3 localhost:${DOCKER_TLS_PORT}/fwd/refresh &>/dev/null
}

function docker-forward-kill () {
    curl -q -m 3 localhost:${DOCKER_TLS_PORT}/fwd/kill &>/dev/null
}

function docker-forward-pid () {
    curl -q -m 3 localhost:${DOCKER_TLS_PORT}/fwd/pid 2>/dev/null
}

function docker-forward-ports () {
    curl -q -m 3 localhost:${DOCKER_TLS_PORT}/fwd/ports 2>/dev/null
}

function docker-get () {
    local TARGET="$1"
    local DEST="${2-.}"
    scp -r ${SSH_OPTIONS} docker@$(docker-host):"$TARGET" "$DEST"
}

function docker-put () {
    local TARGET="$1"
    local DEST="${2-/home/docker/}"
    scp -r ${SSH_OPTIONS} "$TARGET" docker@$(docker-host):"${DEST}"
}

function docker-create-vm () {
    mkdir -p "${VMDIR}"
    curl -L# "https://raw.githubusercontent.com/weikinhuang/boot2docker-vmware-cygwin/master/boot2docker.vmx" > "${VMDIR}/boot2docker.vmx"
    curl -L# "https://raw.githubusercontent.com/weikinhuang/boot2docker-vmware-cygwin/master/boot2docker.vmdk.tar.gz" | tar -zxO > "${VMDIR}/boot2docker.vmdk"

    # allow access to all cores
    local PROC_CORES=$(grep "^processor" -c /proc/cpuinfo)
    sed -i 's/numvcpus = "[0-9]"/numvcpus = "'${PROC_CORES}'"/' "${VMDIR}/boot2docker.vmx"
    sed -i 's/cpuid.coresPerSocket = "[0-9]"/cpuid.coresPerSocket = "'${PROC_CORES}'"/' "${VMDIR}/boot2docker.vmx"

    # set up shared folders
    local COUNTER drive
    COUNTER=0
    for drive in $(fsutil fsinfo drives | tr -d '\r' | tr ' ' '\n' | tail -n+3 | head -n-1); do
        echo 'sharedFolder'${COUNTER}'.present = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.enabled = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.readAccess = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.writeAccess = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.hostPath = "'${drive}'"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.guestName = "'$(echo "$drive" | cut -d ':' -f 1 | tr '[:upper:]' '[:lower:]')'"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.expiration = "never"' >> "${VMDIR}/boot2docker.vmx"
        (( COUNTER += 1 ))
    done
    echo 'sharedFolder.maxNum = "'${COUNTER}'"' >> "${VMDIR}/boot2docker.vmx"
    echo 'isolation.tools.hgfs.disable = "FALSE"' >> "${VMDIR}/boot2docker.vmx"
}

function docker-destroy-vm () {
    docker-vmrun stop hard
    rm -rf "$VMDIR"
}

function docker-vmrun () {
    local VM_CMD=$1
    shift
    "$(cygpath -u "$VMRUN_BIN")" -T ws -gu docker -gp "$DOCKER_USER_PASSWD" "${VM_CMD}" "$(cygpath -w "$VMPATH")" "$@" | tr -d '\r'
}

function docker-ip () {
    docker-vmrun getGuestIPAddress -wait
}

function docker-vmup () {
    docker-vmrun start nogui
}

function docker-vmdown () {
    docker-vmrun stop
}

function docker-reboot () {
    docker-ssh sudo reboot
}

function docker-start-port-forward-manager () {
FWD_SERVER_JS=$(
cat << EOF
var child_process = require("child_process"),
	fs = require("fs"),
	http = require("http"),
	https = require("https"),
	path = require("path"),
	activeTunnel = null,
	activePorts = [],
	dockerHost = process.env.DOCKER_HOST,
	dockerSslPort = process.env.DOCKER_TLS_PORT || 2376,
	dockerTlsCa = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, "ca.pem")),
	dockerTlsCert = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, "cert.pem")),
	dockerTlsKey = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, "key.pem"));
function killActiveTunnel() {
	if (activeTunnel) {
		activeTunnel.kill("SIGINT");
		activeTunnel = null;
		activePorts = [];
	}
}
function getAllContainers(callback) {
	https.request({
		hostname : dockerHost,
		port : dockerSslPort,
		path : "/containers/json?all=1",
		method : "GET",
		cert : dockerTlsCert,
		key : dockerTlsKey,
		ca : dockerTlsCa
	}, function(res) {
		var data = "";
		if (res.statusCode !== 200) {
			return;
		}
		res.on("data", function(d) {
			data += d;
		});
		res.on("end", function() {
			var containers;
			try {
				containers = JSON.parse(data);
			} catch (e) {
				process.stderr.write("Forward server error: " + e.message + "\n");
				return;
			}
			callback(containers);
		});
	}).end();
}
function updatePorts() {
	getAllContainers(function(containers) {
		var ports = [];
		containers.forEach(function(container) {
			(container.Ports || []).forEach(function(portgroup) {
				if (portgroup.PublicPort) {
					ports.push(portgroup.PublicPort);
				}
			});
		});
		if (activePorts.sort().join(",") === ports.sort().join(",")) {
			return;
		}
		killActiveTunnel();
		var args = [
			"-N",
			"-k",
			"-o", "UserKnownHostsFile=/dev/null",
			"-o", "StrictHostKeyChecking=no",
			"-o", "ConnectTimeout=2"
		];
		ports.forEach(function(p) {
			args.push("-L", p + ":" + dockerHost + ":" + p);
		});
		args.push("docker@" + dockerHost);
		activeTunnel = child_process.spawn("ssh", args);
		activePorts = ports;
	});
}
setTimeout(updatePorts, 3000);
process.on("exit", killActiveTunnel);
http.createServer(function(request, response) {
	if ((/^\/fwd\//i).test(request.url)) {
		switch (request.url) {
			case "/fwd/ports":
				response.write(activePorts.join("\n"));
				break;
			case "/fwd/child":
				if (activeTunnel) {
					response.write(activeTunnel.pid + "");
				}
				break;
			case "/fwd/child/kill":
				killActiveTunnel();
				break;
			case "/fwd/pid":
				response.write(process.pid + "");
				break;
			case "/fwd/kill":
				process.nextTick(function() {
					process.exit(0);
				});
				break;
			case "/fwd/refresh":
			default:
				setTimeout(updatePorts, 3000);
				break;
		}
		response.end("");
		return;
	}

	// pipe the request to the docker api in the b2d host
	var proxy = https.request({
		hostname : dockerHost,
		port : dockerSslPort,
		path : request.url,
		method : request.method,
		cert : dockerTlsCert,
		key : dockerTlsKey,
		ca : dockerTlsCa
	}, function(res) {
		res.pipe(response, {
			end : true
		});
	});
	request.pipe(proxy, {
		end : true
	});
})
	.listen(dockerSslPort, "localhost");

EOF
)
    docker-forward-kill
    DOCKER_HOST="$(docker-host)" DOCKER_CERT_PATH="$(cygpath -w $HOME/.docker)" DOCKER_TLS_PORT="$DOCKER_TLS_PORT" node -e "$FWD_SERVER_JS" &
}

function docker-boot2docker-iso-url () {
    # use cloudnativeapps version for vmware support for now
    echo "https://github.com/cloudnativeapps/boot2docker/releases/download/v1.5.0-vmw/boot2docker-1.5.0-vmw.iso"
    return 0

GET_LATEST_BOOT2DOCKER_TAG="$(
cat << EOF
require("https").get({
    host: "api.github.com",
    path: "/repos/boot2docker/boot2docker/releases",
    headers: {"user-agent": "boot2docker-latest"}
}, function(response) {
    var body = "";
    response.on("data", function(d) { body += d; });
    response.on("end", function() {
        try {
            console.log(JSON.parse(body).reduce(function(p, c) { return (!(/^v\d+\.\d+\.\d+/).test(c.name) || p > c.name) ? p : c.name; }, "v0.0.0"));
        } catch (e) {
            console.error(e.message);
        }
    });
});
EOF
)"
    #local LATEST_BOOT2DOCKER_TAG="$(node -e "${GET_LATEST_BOOT2DOCKER_TAG}")"
    local LATEST_BOOT2DOCKER_TAG="v1.5.0"
    if [[ -n "$LATEST_BOOT2DOCKER_TAG" ]] && [[ "$LATEST_BOOT2DOCKER_TAG" != "v0.0.0" ]]; then
        echo "https://github.com/boot2docker/boot2docker/releases/download/${LATEST_BOOT2DOCKER_TAG}/boot2docker.iso"
    else
        exit 1
    fi
}

function docker-download-iso () {
    local ISO_URL="$(docker-boot2docker-iso-url)"
    if [[ -z "${ISO_URL}" ]]; then
        exit 1
    fi

    local ISO_PATH="$VMDIR/boot2docker.iso"
    curl -L# "$ISO_URL" > "$ISO_PATH.new"
    if [[ $? == 0 ]]; then
        rm -f "$ISO_PATH" || true
        mv "$ISO_PATH.new" "$ISO_PATH"
    else
        echo "Failed to download!"
        exit 1
    fi
}

function docker-vm-init () {
    # http://odewahn.github.io/docker-jumpstart/boot2docker.html
    # http://blog.gnu-designs.com/howto-run-boot2docker-in-vmware-fusion-and-esxi-with-shipyard-to-manage-your-containers/

    local ID_RSA_PUB="$(cat ~/.ssh/id_rsa.pub)"

    if docker-vmrun checkToolsState | grep running &>/dev/null; then
        # try to push ssh keys through vmware guest tools
        docker-vmrun runScriptInGuest /bin/sh "\
            mkdir /home/docker/.ssh; \
            chmod 700 /home/docker/.ssh; \
            chmod 600 /home/docker/.ssh/authorized_keys; \
            cat /home/docker/.ssh/authorized_keys | grep \"${ID_RSA_PUB}\" || echo \"${ID_RSA_PUB}\" >> /home/docker/.ssh/authorized_keys"
    else
        echo "Default password is '$DOCKER_USER_PASSWD'"
    fi

docker-ssh << DOCKER_INIT
#!/bin/sh

if ! blkid -c /dev/null | grep boot2docker-data &>/dev/null; then
    echo -e "\033[0;32mFormatting /dev/sda\033[0m"

    echo -ne "\033[0;34m"
    echo -e "n\np\n1\n\n\nw\n" | sudo fdisk /dev/sda
    sudo mkfs.ext4 -L boot2docker-data /dev/sda1
    sudo mkdir /mnt/sda1
    sudo mount -t ext4 /dev/sda1 /mnt/sda1
    sudo mkdir -p /mnt/sda1/var/lib/boot2docker
    echo -ne "\033[0m"
fi

TCL_REPO_BASE=http://tinycorelinux.net/5.x/x86
WORKING_DIR="\$(pwd)"
BUILD_DIR="/tczbuild"
sudo mkdir "\$BUILD_DIR"

echo -e "\033[0;32mBuilding userdata.tar\033[0m"

echo -ne "\033[0;34m"
mkdir /home/docker/.ssh
chmod 700 /home/docker/.ssh
touch /home/docker/.ssh/authorized_keys
sudo touch /mnt/sda1/var/lib/boot2docker/.ash_history
sudo chown docker /mnt/sda1/var/lib/boot2docker/.ash_history
chmod 600 /home/docker/.ssh/authorized_keys
cat /home/docker/.ssh/authorized_keys | grep "${ID_RSA_PUB}" || echo "${ID_RSA_PUB}" >> /home/docker/.ssh/authorized_keys
cd /home/docker

# write history options
# Don't put duplicate lines in the history.
echo "export HISTCONTROL=\\\$HISTCONTROL\\\${HISTCONTROL+,}ignoredups" >> /home/docker/.profile
# Ignore some controlling instructions: exit, ls, empty cd, pwd, date, help pages
echo "export HISTIGNORE=\\\$'[ \t]*:&:[fb]g:exit:ls:ls -?::ls -??:ll:history:cd:cd -:cd ~:cd ..:..:pwd:date:* --help'" >> /home/docker/.profile
# Larger bash history (allow 32³ entries; default is 500)
echo "export HISTSIZE=32768" >> /home/docker/.profile
echo "export HISTFILESIZE=32768" >> /home/docker/.profile

ln -sf /var/lib/boot2docker/.ash_history .ash_history
sudo tar -vcf /mnt/sda1/var/lib/boot2docker/userdata.tar .ssh .ash_history .profile
cd "\$WORKING_DIR"
echo -ne "\033[0m"

echo search localdomain > /etc/resolv.conf
echo nameserver 8.8.8.8 >> /etc/resolv.conf
echo nameserver 8.8.4.4 >> /etc/resolv.conf

echo -e "\033[0;32mDownloading additional modules\033[0m"

echo -ne "\033[0;34m"
sudo mkdir -p /mnt/sda1/var/lib/boot2docker/tcz

sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/cifs-utils.tcz \$TCL_REPO_BASE/tcz/cifs-utils.tcz
sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/ncurses-common.tcz \$TCL_REPO_BASE/tcz/ncurses-common.tcz
sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/ncurses-terminfo.tcz \$TCL_REPO_BASE/tcz/ncurses-terminfo.tcz
sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/ncurses-utils.tcz \$TCL_REPO_BASE/tcz/ncurses-utils.tcz
sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/ncurses.tcz \$TCL_REPO_BASE/tcz/ncurses.tcz
sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/htop.tcz \$TCL_REPO_BASE/tcz/htop.tcz

# this is for building images later
sudo wget -O \$BUILD_DIR/squashfs-tools-4.x.tcz \$TCL_REPO_BASE/tcz/squashfs-tools-4.x.tcz
tce-load -i \$BUILD_DIR/squashfs-tools-4.x.tcz

echo -ne "\033[0m"

if [[ ! -e /usr/local/bin/vmtoolsd ]]; then
    echo -e "\033[0;32mDownloading open vmware tools\033[0m"

    echo -ne "\033[0;34m"
    sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/procps.tcz \$TCL_REPO_BASE/tcz/procps.tcz
    sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/glib2.tcz \$TCL_REPO_BASE/tcz/glib2.tcz
    sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/libtirpc.tcz \$TCL_REPO_BASE/tcz/libtirpc.tcz
    sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/libffi.tcz \$TCL_REPO_BASE/tcz/libffi.tcz

    sudo mkdir \$BUILD_DIR/libdnet
    sudo mkdir \$BUILD_DIR/open-vm-tools
    curl -L# https://github.com/vmware/tcl-container/releases/download/v9.4.6/libdnet.tgz | sudo tar -C \$BUILD_DIR/libdnet -xz
    curl -L# https://github.com/vmware/tcl-container/releases/download/v9.4.6/open-vm-tools.tgz | sudo tar -C \$BUILD_DIR/open-vm-tools -xz
    sudo mkdir -p \$BUILD_DIR/open-vm-tools/etc/vmware-tools/scripts/vmware
    sudo mkdir -p \$BUILD_DIR/open-vm-tools/sbin
    sudo mkdir -p \$BUILD_DIR/open-vm-tools/usr/local/bin
    sudo curl -L# -o \$BUILD_DIR/open-vm-tools/etc/vmware-tools/scripts/vmware/network https://raw.githubusercontent.com/frapposelli/boot2docker/vmware-support/rootfs/rootfs/etc/vmware-tools/scripts/vmware/network
    sudo curl -L# -o \$BUILD_DIR/open-vm-tools/usr/local/bin/lsb_release https://raw.githubusercontent.com/frapposelli/boot2docker/vmware-support/rootfs/rootfs/usr/local/bin/lsb_release

    sudo chmod 755 \$BUILD_DIR/open-vm-tools/etc/vmware-tools/scripts/vmware/network
    sudo chmod 755 \$BUILD_DIR/open-vm-tools/usr/local/bin/lsb_release

    cd \$BUILD_DIR
    sudo mksquashfs libdnet /mnt/sda1/var/lib/boot2docker/tcz/libdnet.tcz
    sudo mksquashfs open-vm-tools /mnt/sda1/var/lib/boot2docker/tcz/open-vm-tools.tcz
    cd "\$WORKING_DIR"
    echo -ne "\033[0m"
fi

echo -e "\033[0;32mInstalling scripts to fix behaviors\033[0m"
sudo mkdir -p \$BUILD_DIR/b2d-vm-fixes

echo -ne "\033[0;32mFix resolv.conf issue\033[0m"

echo -ne "\033[0;34m"
sudo mkdir -p \$BUILD_DIR/b2d-vm-fixes/usr/share/udhcpc
sudo curl -L# -o \$BUILD_DIR/b2d-vm-fixes/usr/share/udhcpc/default.script https://raw.githubusercontent.com/SvenDowideit/boot2docker/noclobber-resolve.conf/rootfs/rootfs/usr/share/udhcpc/default.script
sudo chmod 755 \$BUILD_DIR/b2d-vm-fixes/usr/share/udhcpc/default.script
echo -ne "\033[0m"

if [[ ! -e /sbin/shutdown ]]; then
    echo -ne "\033[0;34m"
    echo -e "\033[0;32mAdd /sbin/shutdown for vmware\033[0m"
    sudo mkdir -p \$BUILD_DIR/b2d-vm-fixes/sbin
    sudo curl -L# -o \$BUILD_DIR/b2d-vm-fixes/sbin/shutdown https://raw.githubusercontent.com/frapposelli/boot2docker/vmware-support/rootfs/rootfs/sbin/shutdown
    sudo chmod 755 \$BUILD_DIR/b2d-vm-fixes/sbin/shutdown
    echo -ne "\033[0m"
fi

cd \$BUILD_DIR
sudo mksquashfs b2d-vm-fixes /mnt/sda1/var/lib/boot2docker/tcz/b2d-vm-fixes.tcz
cd "\$WORKING_DIR"
echo -e "\033[0m"

echo -e "\033[0;32mInstalling local boot script and profile\033[0m"

echo -e "\033[0;34m"

sudo tee /mnt/sda1/var/lib/boot2docker/bootlocal.sh << BOOT2DOCKER_INIT_SCRIPT
#!/bin/sh

su - docker -c 'tce-load -i /var/lib/boot2docker/tcz/*.tcz'

if [[ ! -e /etc/rc.d/vmtoolsd ]]; then
    /usr/local/bin/vmtoolsd --background /var/run/vmtoolsd.pid
fi

echo > /var/lib/boot2docker/docker.log

BOOT2DOCKER_INIT_SCRIPT

sudo chmod 755 /mnt/sda1/var/lib/boot2docker/bootlocal.sh

sudo tee /mnt/sda1/var/lib/boot2docker/profile << BOOT2DOCKER_PROFILE_SCRIPT
#!/bin/sh

EXTRA_ARGS="--insecure-registry localhost"

BOOT2DOCKER_PROFILE_SCRIPT

sudo chmod 755 /mnt/sda1/var/lib/boot2docker/profile

echo -e "\033[0m"

echo -e "\033[0;32mRebooting\033[0m"
sudo reboot

DOCKER_INIT
    sleep 60

    echo -e "\033[0;32mPulling ssl certs\033[0m\033[0;34m"
    mkdir $HOME/.docker/ &>/dev/null
    docker-get '~/.docker/*' $HOME/.docker/
    echo -e "\033[0m"

    echo -e "\033[0;32mReady\033[0m"
}

# ======================================================================================================================
# Start of commnds
# ======================================================================================================================

SHELL_DOCKER_ACTION="$1"
shift
case "$SHELL_DOCKER_ACTION" in
    ssh)
        docker-ssh "$@"
    ;;
    ssh-batch)
        docker-ssh-batch-mode "$@"
    ;;
    curl)
        curl --insecure --cert ~/.docker/cert.pem --key ~/.docker/key.pem "$@"
    ;;
    get)
        docker-get "$@"
    ;;
    put)
        docker-put "$@"
    ;;
    vm)
        SHELL_DOCKER_SUBACTION="$1"
        shift
        case "$SHELL_DOCKER_SUBACTION" in
            build)
                docker-create-vm
                docker-download-iso
                docker-vmup
                sleep 120
                docker-vm-init
            ;;
            cifs)
                docker-mount-cifs "$@"
            ;;
            clean)
                echo -ne "\033[0;32m"
                echo "Cleaning ALL up docker images"
                echo -ne "\033[0m\033[0;34m"
                docker-ssh docker rm $(docker-ssh docker ps -a -q)
                docker-ssh docker rmi $(docker-ssh docker images | grep "^<none>" | awk "{print $3}")
                echo -ne "\033[0m\033[0;32m"
                echo "Shrinking disk"
                echo -ne "\033[0m\033[0;34m"
                docker-ssh sudo vmware-toolbox-cmd disk shrink /mnt/sda1
                echo -ne "\033[0m"
            ;;
            create)
                echo -ne "\033[0;34m"
                docker-create-vm
                docker-download-iso
                echo -ne "\033[0m"
            ;;
            destroy)
                docker-destroy-vm
            ;;
            download)
                docker-download-iso
            ;;
            fwd)
                SHELL_DOCKER_FWD_SUBACTION="$1"
                shift
                case "$SHELL_DOCKER_FWD_SUBACTION" in
                    pid)
                        docker-forward-pid
                    ;;
                    ports)
                        docker-forward-ports
                    ;;
                    published)
                        docker-ssh 'for x in $(docker ps -q); do docker port $x; done'
                    ;;
                    reload)
                        docker-refresh-port-forwards
                    ;;
                    start)
                        docker-start-port-forward-manager
                    ;;
                    stop)
                        docker-forward-kill
                    ;;
                    *)
                        exit 1
                    ;;
                esac
            ;;
            init)
                docker-vm-init
            ;;
            mount)
                docker-mount-all-admin-shares
            ;;
            poweroff)
                docker-forward-kill
                docker-vmrun stop hard
            ;;
            reboot)
                docker-forward-kill
                docker-reboot
                sleep 20
                docker-mount-all-admin-shares
                docker-start-port-forward-manager
            ;;
            run)
                docker-vmrun "$@"
            ;;
            *)
                exit 1
            ;;
        esac
    ;;
    ip)
        docker-ip
    ;;
    up)
        docker-vmup
        sleep 20
        docker-mount-all-admin-shares
        docker-start-port-forward-manager
    ;;
    down)
        docker-forward-kill
        docker-vmdown
    ;;
    help)
        docker-ssh docker help "$@"
        if [[ $# == 0 ]]; then
            echo
            echo 'Additional options for windows docker script:'
            echo
            echo '    curl      Make a curl request against the docker api, use https://localhost:2376/'
            echo '    down      Stop the boot2docker vm'
            echo '    get       Get a file from the boot2docker vm'
            echo '    ip        Get the ip of the boot2docker vm'
            echo '    put       Send a file to the boot2docker vm'
            echo '    ssh       SSH into docker server or run remote commands'
            echo '    up        Start the boot2docker vm'
            echo '    vm        Execute actions against the virtual machine, subactions:'
            echo '    ├ build       Create and initialize the boot2docker vm'
            echo '    ├ cifs        Mount a local share on the boot2docker vm'
            echo '    ├ clean       Remove unused docker images and containers'
            echo '    ├ create      Create the boot2docker vm'
            echo '    ├ destroy     Destroy the boot2docker vm'
            echo '    ├ download    Download the latest boot2docker.iso'
            echo '    ├ fwd         Forwarding server, subactions:'
            echo '    │ ├ pid           Get the port forwarding managing server pid'
            echo '    │ ├ ports         List active ports forwarded to the host'
            echo '    │ ├ published     List published ports from all containers'
            echo '    │ ├ reload        Notify the port forwarding managing server of port changes'
            echo '    │ ├ start         Start the port forwarding managing server'
            echo '    │ └ stop          Stop port forwarding managing server'
            echo '    ├ init        Initialize the boot2docker vm'
            echo '    ├ mount       Mount all administrative shares'
            echo '    ├ poweroff    Power off the boot2docker vm'
            echo '    ├ reboot      Reboot the boot2docker vm'
            echo '    └ run         Run a vmware command against boot2docker vm'
        fi
    ;;
    run)
        docker-refresh-port-forwards
        args=( )
        prev_arg=

        for arg in "$@"; do
            # if argument is a file, then expand it to windows paths
            if [[ "$prev_arg" == '-v' ]]; then
                # docker doesn't support -vPATH:PATH only -v PATH:PATH
                # previous arg was a volume indicator
                dir="$(echo "${arg}" | cut -d':' -f1)"
                if [[ -e "$dir" && "$dir" != '/tmp' ]]; then
                    map="$(echo "${arg}" | cut -d':' -f2)"
                    res="/mnt/hgfs$(realpath "${dir}")"
                    if [[ -n "$map" && "$arg" =~ : ]]; then
                        res="${res}:${map}"
                    else
                        res="${res}:$(realpath "${dir}")"
                    fi
                else
                    res="${arg}"
                fi
                args=("${args[@]}" "$(printf '%q' "${res}")")
            else
                # append
                args=("${args[@]}" "$arg")
            fi
            prev_arg="$arg"
        done
        # send the remapped volume paths
        docker-ssh docker "$SHELL_DOCKER_ACTION" "${args[@]}"
        docker-refresh-port-forwards
    ;;
    start|stop|kill)
        docker-refresh-port-forwards
        docker-ssh docker "$SHELL_DOCKER_ACTION" "$@"
        docker-refresh-port-forwards
    ;;
    build)
        # always try to change the working directory to $PWD
        docker-ssh cd $(printf '%q' "/mnt/hgfs$(realpath "$(pwd)")") \&\>/dev/null \; docker build "$@"
    ;;
    *)
        # default run docker command on remote host
        docker-ssh docker "$SHELL_DOCKER_ACTION" $(docker-escape-args "$@")
    ;;
esac
