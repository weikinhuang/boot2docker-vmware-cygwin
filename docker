#!/bin/bash

SCRIPT="$0"

SSH_OPTIONS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o ConnectTimeout=5"
VMRUN_BIN='C:\Program Files (x86)\VMware\VMware Workstation\vmrun.exe'
VM_ROOT_DIR="${VM_ROOT_DIR-"$HOME/Documents/Virtual Machines"}"
VMPATH="$(cygpath -w "$(realpath "${VM_ROOT_DIR}")")"'\boot2docker\boot2docker.vmx'
VMDKPATH="$(cygpath -w "$(realpath "${VM_ROOT_DIR}")")"'\boot2docker\boot2docker.vmdk'
VMDIR="$(dirname "$(cygpath "$VMPATH")")"
LATEST_BOOT2DOCKER_TAG="v1.10.1"
LATEST_DOCKER_COMPOSE_TAG="1.6.0"
DOCKER_TLS_PORT=2376
DOCKER_USER_PASSWD=tcuser

function docker-host () {
    if [[ -n "${DOCKER_HOST}" ]]; then
        echo "${DOCKER_HOST}"
        return 0
    fi
    echo $(docker-ip)
}

function docker-ssh () {
    if [[ ! -t 0 || ! -t 1 ]]; then
        # pipe mode
        ssh ${SSH_OPTIONS} docker@$(docker-host) -- "$@"
    else
        # non pipe mode
        ssh ${SSH_OPTIONS} -t docker@$(docker-host) -- "$@"
    fi
}

function docker-ssh-batch-mode () {
    ssh ${SSH_OPTIONS} -o 'Batchmode yes' docker@$(docker-host) -- "$@"
}

function docker-escape-args () {
    if [[ $# == 0 ]]; then
        return
    fi
    args=( )
    for arg in "$@"; do
        args=("${args[@]}" $(printf '%q' "$arg"))
    done
    echo "${args[@]}"
}

function docker-refresh-port-forwards () {
    curl -q -m 3 localhost:${DOCKER_TLS_PORT}/fwd/refresh &>/dev/null
}

function docker-forward-kill () {
    curl -q -m 3 localhost:${DOCKER_TLS_PORT}/fwd/kill &>/dev/null
}

function docker-forward-pid () {
    curl -q -m 3 localhost:${DOCKER_TLS_PORT}/fwd/pid 2>/dev/null
}

function docker-forward-ports () {
    curl -q -m 3 localhost:${DOCKER_TLS_PORT}/fwd/ports 2>/dev/null
}

function docker-get () {
    local TARGET="$1"
    local DEST="${2-.}"
    scp -r ${SSH_OPTIONS} docker@$(docker-host):"$TARGET" "$DEST"
}

function docker-create-vm () {
    # allow differently sized vms
    local VMDK_SIZE="${VMDK_SIZE-16G}"

    mkdir -p "${VMDIR}"

    curl -L# "https://raw.githubusercontent.com/weikinhuang/boot2docker-vmware-cygwin/master/boot2docker.vmx" > "${VMDIR}/boot2docker.vmx"
    curl -L# "https://raw.githubusercontent.com/weikinhuang/boot2docker-vmware-cygwin/master/boot2docker.vmdk.${VMDK_SIZE}.tar.gz" | tar -zxO > "${VMDIR}/boot2docker.vmdk"

    # allow access to all cores
    local PROC_CORES=$(grep "^processor" -c /proc/cpuinfo)
    sed -i 's/numvcpus = "[0-9]"/numvcpus = "'${PROC_CORES}'"/' "${VMDIR}/boot2docker.vmx"
    sed -i 's/cpuid.coresPerSocket = "[0-9]"/cpuid.coresPerSocket = "'${PROC_CORES}'"/' "${VMDIR}/boot2docker.vmx"

    # set up shared folders
    local COUNTER drive
    COUNTER=0
    for drive in $(fsutil fsinfo drives | tr -d '\r' | tr ' ' '\n' | tail -n+3 | head -n-1); do
        echo 'sharedFolder'${COUNTER}'.present = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.enabled = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.readAccess = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.writeAccess = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.hostPath = "'${drive}'"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.guestName = "'$(echo "$drive" | cut -d ':' -f 1 | tr '[:upper:]' '[:lower:]')'"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.expiration = "never"' >> "${VMDIR}/boot2docker.vmx"
        (( COUNTER += 1 ))
    done
    echo 'sharedFolder.maxNum = "'${COUNTER}'"' >> "${VMDIR}/boot2docker.vmx"
    echo 'isolation.tools.hgfs.disable = "FALSE"' >> "${VMDIR}/boot2docker.vmx"

    # fix cygwin permissions...
    setfacl -b "${VMDIR}"
    chmod -R 755 "${VMDIR}"
    sleep 2
}

function docker-destroy-vm () {
    docker-vmrun stop hard
    rm -rf "$VMDIR"
}

function docker-vmrun () {
    local VM_CMD=$1
    shift
    "$(cygpath -u "$VMRUN_BIN")" -T ws -gu docker -gp "$DOCKER_USER_PASSWD" "${VM_CMD}" "$(cygpath -w "$VMPATH")" "$@" | tr -d '\r'
}

function docker-ip () {
    docker-vmrun getGuestIPAddress -wait
}

function docker-vmup () {
    docker-vmrun start nogui
}

function docker-vmdown () {
    docker-vmrun stop
}

function docker-vm-is-on () {
    "$(cygpath -u "$VMRUN_BIN")" list | tr -d '\r' | sed 's/\\/\//g' | grep "$(cygpath -w "$VMPATH" | sed 's/\\/\//g')" 2>&1 >/dev/null
}

function docker-reboot () {
    docker-ssh sudo reboot
}

function docker-startup () {
    if ! docker-vm-is-on; then
        docker-vmup
        sleep 20
        docker-start-port-forward-manager
    fi
}

function docker-start-port-forward-manager () {
FWD_SERVER_JS=$(
cat << EOF
var child_process = require("child_process"),
	fs = require("fs"),
	http = require("http"),
	https = require("https"),
	path = require("path"),
	activeTunnel = null,
	activePorts = [],
	dockerHost = process.env.DOCKER_HOST,
	dockerSslPort = process.env.DOCKER_TLS_PORT || 2376,
	dockerTlsCa = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, "ca.pem")),
	dockerTlsCert = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, "cert.pem")),
	dockerTlsKey = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, "key.pem"));
function killActiveTunnel() {
	if (activeTunnel) {
		activeTunnel.kill("SIGINT");
		activeTunnel = null;
		activePorts = [];
	}
}
function getAllContainers(callback) {
	var req = https.request({
		hostname : dockerHost,
		port : dockerSslPort,
		path : "/containers/json?all=1",
		method : "GET",
		cert : dockerTlsCert,
		key : dockerTlsKey,
		ca : dockerTlsCa,
		rejectUnauthorized : false
	}, function(res) {
		var data = "";
		if (res.statusCode !== 200) {
			return;
		}
		res.on("data", function(d) {
			data += d;
		});
		res.on("end", function() {
			var containers;
			try {
				containers = JSON.parse(data);
			} catch (e) {
				process.stderr.write("Forward server error: " + e.message + "\n");
				return;
			}
			callback(containers);
		});
	});
	req.on("error", function(err) {
		switch (err.message) {
			case "connect ETIMEDOUT":
			case "connect ECONNREFUSED":
				// try again in a few seconds
				setTimeout(function() {
					getAllContainers(callback);
				}, 3000);
				break;
			default:
				console.log(err);
				break;
		}
	});
	req.end();
}
function updatePorts() {
	getAllContainers(function(containers) {
		var ports = [];
		containers.forEach(function(container) {
			(container.Ports || []).forEach(function(portgroup) {
				if (portgroup.PublicPort) {
					ports.push(portgroup.PublicPort);
				}
			});
		});
		if (activePorts.sort().join(",") === ports.sort().join(",")) {
			return;
		}
		killActiveTunnel();
		var args = [
			"-N",
			"-k",
			"-o", "UserKnownHostsFile=/dev/null",
			"-o", "StrictHostKeyChecking=no",
			"-o", "ConnectTimeout=2"
		];
		ports.forEach(function(p) {
			args.push("-L", p + ":" + dockerHost + ":" + p);
		});
		args.push("docker@" + dockerHost);
		activeTunnel = child_process.spawn("ssh", args);
		activePorts = ports;
	});
}
setTimeout(updatePorts, 3000);
process.on("exit", killActiveTunnel);
http.createServer(function(request, response) {
	if ((/^\/fwd\//i).test(request.url)) {
		switch (request.url) {
			case "/fwd/ports":
				response.write(activePorts.join("\n"));
				break;
			case "/fwd/child":
				if (activeTunnel) {
					response.write(activeTunnel.pid + "");
				}
				break;
			case "/fwd/child/kill":
				killActiveTunnel();
				break;
			case "/fwd/pid":
				response.write(process.pid + "");
				break;
			case "/fwd/kill":
				process.nextTick(function() {
					process.exit(0);
				});
				break;
			case "/fwd/refresh":
			default:
				// try updating multiple times
				setTimeout(updatePorts, 3000);
				setTimeout(updatePorts, 6000);
				setTimeout(updatePorts, 9000);
				setTimeout(updatePorts, 12000);
				break;
		}
		response.end("");
		return;
	}

	// pipe the request to the docker api in the b2d host
	var proxy = https.request({
		hostname : dockerHost,
		port : dockerSslPort,
		path : request.url,
		method : request.method,
		cert : dockerTlsCert,
		key : dockerTlsKey,
		ca : dockerTlsCa,
		rejectUnauthorized : false
	}, function(res) {
		res.pipe(response, {
			end : true
		});
	});
	request.pipe(proxy, {
		end : true
	});
})
	.listen(dockerSslPort, "localhost");

EOF
)
    docker-forward-kill
    DOCKER_HOST="$(docker-host)" \
    DOCKER_CERT_PATH="$(cygpath -w $HOME/.docker)" \
    DOCKER_TLS_PORT="$DOCKER_TLS_PORT" \
        node -e "$FWD_SERVER_JS" &
}

function docker-boot2docker-iso-url () {
    echo "https://github.com/boot2docker/boot2docker/releases/download/${LATEST_BOOT2DOCKER_TAG}/boot2docker.iso"
}

function docker-download-iso () {
    local ISO_URL="$(docker-boot2docker-iso-url)"
    if [[ -z "${ISO_URL}" ]]; then
        exit 1
    fi

    local ISO_PATH="$VMDIR/boot2docker.iso"
    curl -L# "$ISO_URL" > "$ISO_PATH.new"
    if [[ $? == 0 ]]; then
        rm -f "$ISO_PATH" || true
        mv "$ISO_PATH.new" "$ISO_PATH"
    else
        echo "Failed to download!"
        exit 1
    fi
}

function docker-vm-init () {
    # http://odewahn.github.io/docker-jumpstart/boot2docker.html
    # http://blog.gnu-designs.com/howto-run-boot2docker-in-vmware-fusion-and-esxi-with-shipyard-to-manage-your-containers/

    local ID_RSA_PUB="$(cat ~/.ssh/id_rsa.pub)"

    if docker-vmrun checkToolsState | grep running &>/dev/null; then
        # try to push ssh keys through vmware guest tools
        docker-vmrun runScriptInGuest /bin/sh "\
            sudo chown docker -R /home/docker/.ssh; \
            mkdir /home/docker/.ssh || true; \
            chmod 700 /home/docker/.ssh || true; \
            chmod 600 /home/docker/.ssh/authorized_keys; \
            cat /home/docker/.ssh/authorized_keys | grep \"${ID_RSA_PUB}\" || echo \"${ID_RSA_PUB}\" >> /home/docker/.ssh/authorized_keys; \
            sudo chown docker -R /home/docker/.ssh; \
            "
    else
        echo "Default password is '$DOCKER_USER_PASSWD'"
    fi

docker-ssh << DOCKER_INIT
#!/bin/sh

if ! blkid -c /dev/null | grep boot2docker-data &>/dev/null; then
    echo -e "\033[0;32mFormatting /dev/sda\033[0m"

    echo -ne "\033[0;34m"
    echo -e "n\np\n1\n\n\nw\n" | sudo fdisk /dev/sda
    sudo mkfs.ext4 -L boot2docker-data /dev/sda1
    sudo mkdir /mnt/sda1
    sudo mount -t ext4 /dev/sda1 /mnt/sda1
    sudo mkdir -p /mnt/sda1/var/lib/boot2docker
    echo -ne "\033[0m"
fi

TCL_REPO_BASE=http://tinycorelinux.net/6.x/x86_64
WORKING_DIR="\$(pwd)"
BUILD_DIR="/tczbuild"
sudo mkdir "\$BUILD_DIR"

echo -e "\033[0;32mBuilding userdata.tar\033[0m"

echo -ne "\033[0;34m"
mkdir /home/docker/.ssh
sudo chown docker -R /home/docker/.ssh
chmod 700 /home/docker/.ssh
touch /home/docker/.ssh/authorized_keys
sudo touch /mnt/sda1/var/lib/boot2docker/.ash_history
sudo chown docker /mnt/sda1/var/lib/boot2docker/.ash_history
chmod 600 /home/docker/.ssh/authorized_keys
cat /home/docker/.ssh/authorized_keys | grep "${ID_RSA_PUB}" || echo "${ID_RSA_PUB}" >> /home/docker/.ssh/authorized_keys
cd /home/docker

# write history options
# Don't put duplicate lines in the history.
echo "export HISTCONTROL=\\\$HISTCONTROL\\\${HISTCONTROL+,}ignoredups" >> /home/docker/.profile
# Ignore some controlling instructions: exit, ls, empty cd, pwd, date, help pages
echo "export HISTIGNORE=\\\$'[ \t]*:&:[fb]g:exit:ls:ls -?::ls -??:ll:history:cd:cd -:cd ~:cd ..:..:pwd:date:* --help'" >> /home/docker/.profile
# Larger bash history (allow 32³ entries; default is 500)
echo "export HISTSIZE=32768" >> /home/docker/.profile
echo "export HISTFILESIZE=32768" >> /home/docker/.profile

ln -sf /var/lib/boot2docker/.ash_history .ash_history
sudo tar -vcf /mnt/sda1/var/lib/boot2docker/userdata.tar .ssh .ash_history .profile
cd "\$WORKING_DIR"
echo -ne "\033[0m"

echo search localdomain > /etc/resolv.conf
echo nameserver 8.8.8.8 >> /etc/resolv.conf
echo nameserver 8.8.4.4 >> /etc/resolv.conf

echo -e "\033[0;32mDownloading additional modules\033[0m"

echo -ne "\033[0;34m"
sudo mkdir -p /mnt/sda1/var/lib/boot2docker/tcz

sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/ncurses-terminfo.tcz \$TCL_REPO_BASE/tcz/ncurses-terminfo.tcz
sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/ncurses-utils.tcz \$TCL_REPO_BASE/tcz/ncurses-utils.tcz
sudo wget -O /mnt/sda1/var/lib/boot2docker/tcz/htop.tcz \$TCL_REPO_BASE/tcz/htop.tcz

echo -ne "\033[0m"

echo -e "\033[0;32mInstalling local boot script and profile\033[0m"

echo -e "\033[0;34m"

sudo tee /mnt/sda1/var/lib/boot2docker/bootlocal.sh << BOOT2DOCKER_INIT_SCRIPT
#!/bin/sh

su - docker -c 'tce-load -i /var/lib/boot2docker/tcz/*.tcz'

echo > /var/lib/boot2docker/docker.log

BOOT2DOCKER_INIT_SCRIPT

sudo chmod 755 /mnt/sda1/var/lib/boot2docker/bootlocal.sh

sudo tee /mnt/sda1/var/lib/boot2docker/profile << BOOT2DOCKER_PROFILE_SCRIPT
#!/bin/sh

EXTRA_ARGS="--insecure-registry localhost"

BOOT2DOCKER_PROFILE_SCRIPT

sudo chmod 755 /mnt/sda1/var/lib/boot2docker/profile

# force regenerating the docker tls certs
sudo rm -rf /home/docker/.docker
sudo rm -rf /var/lib/boot2docker/tls

echo -e "\033[0m"

echo -e "\033[0;32mRebooting\033[0m"
sudo reboot

DOCKER_INIT
    sleep 60

    echo -e "\033[0;32mPulling ssl certs\033[0m\033[0;34m"
    mkdir $HOME/.docker/ &>/dev/null
    docker-get '~/.docker/*' $HOME/.docker/
    touch $HOME/.docker/.docker_history
    echo -ne "\033[0m"

    echo -e "\033[0;32mReady\033[0m"
}

function docker-ps1 () {
    local PS1_COLOR_RESET='\[\e[0m\]'
    local PS1_COLOR_EXIT_ERROR='\[\e[38;5;196m\]'
    local PS1_COLOR_USER='\[\e[38;5;197m\]'
    local PS1_COLOR_HOST='\[\e[38;5;208m\]'
    local PS1_COLOR_HOST_SCREEN='\[\e[4m\]\[\e[38;5;214m\]'
    local PS1_COLOR_WORK_DIR='\[\e[38;5;142m\]'

    local PS1_EXIT_STATUS='$(EXIT="$?"; [[ $EXIT -ne 0 ]] && echo -n "(E:${EXIT}) ")'

    echo "[${PS1_COLOR_EXIT_ERROR}${PS1_EXIT_STATUS}${PS1_COLOR_RESET}${PS1_COLOR_USER}\u${PS1_COLOR_RESET}@${PS1_COLOR_HOST_SCREEN}docker${PS1_COLOR_RESET}.${PS1_COLOR_HOST}\h${PS1_COLOR_RESET} ${PS1_COLOR_WORK_DIR}\W${PS1_COLOR_RESET}]$(echo -e "\xE2\x99\xAB") "
}

# ======================================================================================================================
# Start of commnds
# ======================================================================================================================

SHELL_DOCKER_ACTION="$1"
shift
case "$SHELL_DOCKER_ACTION" in
    ssh)
        docker-ssh "$@"
    ;;
    ssh-batch)
        docker-ssh-batch-mode "$@"
    ;;
    curl)
        curl --insecure --cert ~/.docker/cert.pem --key ~/.docker/key.pem "$@"
    ;;
    vm)
        SHELL_DOCKER_SUBACTION="$1"
        shift
        case "$SHELL_DOCKER_SUBACTION" in
            build)
                docker-create-vm
                docker-download-iso
                docker-vmup
                sleep 120
                docker-vm-init
            ;;
            clean)
                echo -ne "\033[0;32m"
                echo "Cleaning ALL up docker images"
                echo -ne "\033[0m\033[0;34m"
                if [[ $1 == "-a" ]]; then
                    docker-ssh docker rm $(docker-ssh docker ps -a -q)
                fi
                docker-ssh docker rmi $(docker-ssh docker images | grep "^<none>" | awk '{print $3}')
                echo -ne "\033[0m\033[0;32m"
                echo "Shrinking disk"
                echo -ne "\033[0m\033[0;34m"
                VMDK_SIZE_OLD=$(du -hs "$(cygpath -u "$VMDKPATH")" | awk '{print $1}')
                docker-ssh sudo vmware-toolbox-cmd disk shrink /mnt/sda1
                VMDK_SIZE_NEW=$(du -hs "$(cygpath -u "$VMDKPATH")" | awk '{print $1}')
                echo -ne "\033[0m"
                echo -e "\033[0;32mOld Size: \033[1;32m${VMDK_SIZE_OLD}\033[0m"
                echo -ne "\033[0m"
                echo -e "\033[0;32mNew Size: \033[1;32m${VMDK_SIZE_NEW}\033[0m"
                echo -ne "\033[0m"
            ;;
            create)
                echo -ne "\033[0;34m"
                docker-create-vm
                docker-download-iso
                echo -ne "\033[0m"
            ;;
            destroy)
                docker-destroy-vm
            ;;
            download)
                docker-download-iso
            ;;
            fwd)
                SHELL_DOCKER_FWD_SUBACTION="$1"
                shift
                case "$SHELL_DOCKER_FWD_SUBACTION" in
                    pid)
                        docker-forward-pid
                    ;;
                    ports)
                        docker-forward-ports
                    ;;
                    published)
                        docker-ssh 'for x in $(docker ps -q); do docker port $x; done'
                    ;;
                    reload)
                        docker-refresh-port-forwards
                    ;;
                    start)
                        docker-start-port-forward-manager
                    ;;
                    stop)
                        docker-forward-kill
                    ;;
                    *)
                        exit 1
                    ;;
                esac
            ;;
            init)
                docker-vm-init
            ;;
            poweroff)
                docker-forward-kill
                docker-vmrun stop hard
            ;;
            reboot)
                docker-forward-kill
                docker-reboot
                sleep 20
                docker-start-port-forward-manager
            ;;
            run)
                docker-vmrun "$@"
            ;;
            *)
                exit 1
            ;;
        esac
    ;;
    ip)
        docker-ip
    ;;
    up)
        docker-vmup
        sleep 20
        docker-start-port-forward-manager
    ;;
    down)
        docker-forward-kill
        docker-vmdown
    ;;
    help)
        docker-ssh docker help "$@"
        if [[ $# == 0 ]]; then
            echo
            echo 'Additional options for windows docker script:'
            echo
            echo '    curl      Make a curl request against the docker api, use https://localhost:2376/'
            echo '    down      Stop the boot2docker vm'
            echo '    ip        Get the ip of the boot2docker vm'
            echo '    ssh       SSH into docker server or run remote commands'
            echo '    up        Start the boot2docker vm'
            echo '    vm        Execute actions against the virtual machine, subactions:'
            echo '    ├ build       Create and initialize the boot2docker vm'
            echo '    ├ clean       Remove unused docker images and containers. Use -a to remove stopped containers'
            echo '    ├ create      Create the boot2docker vm'
            echo '    ├ destroy     Destroy the boot2docker vm'
            echo '    ├ download    Download the latest boot2docker.iso'
            echo '    ├ fwd         Forwarding server, subactions:'
            echo '    │ ├ pid           Get the port forwarding managing server pid'
            echo '    │ ├ ports         List active ports forwarded to the host'
            echo '    │ ├ published     List published ports from all containers'
            echo '    │ ├ reload        Notify the port forwarding managing server of port changes'
            echo '    │ ├ start         Start the port forwarding managing server'
            echo '    │ └ stop          Stop port forwarding managing server'
            echo '    ├ init        Initialize the boot2docker vm'
            echo '    ├ poweroff    Power off the boot2docker vm'
            echo '    ├ reboot      Reboot the boot2docker vm'
            echo '    └ run         Run a vmware command against boot2docker vm'
        fi
    ;;
    run)
        docker-startup
        docker-refresh-port-forwards
        args=( )
        prev_arg=

        # generate a persistient history file
        args=("${args[@]}" "-e" "HISTFILE=/root/.bash_history")
        args=("${args[@]}" "-e" "$(printf '%q' "HISTIGNORE=${HISTIGNORE}")")
        args=("${args[@]}" "-e" "$(printf '%q' "HISTCONTROL=${HISTCONTROL}")")
        args=("${args[@]}" "-e" "HISTSIZE=${HISTSIZE}")
        args=("${args[@]}" "-e" "HISTFILESIZE=${HISTFILESIZE}")
        args=("${args[@]}" "-e" "$(printf '%q' "PROMPT_COMMAND=history -a")")
        args=("${args[@]}" "-e" "$(printf '%q' "PS1=$(docker-ps1)")")
        args=("${args[@]}" "-e" "$(printf '%q' "PS2=$(echo -e "\xe2\x86\x92") ")")
        # args=("${args[@]}" "-v" "/var/lib/boot2docker/.docker_history:/root/.bash_history")
        args=("${args[@]}" "-v" "$(printf '%q' "/mnt/hgfs$(realpath "$HOME")/.docker/.docker_history:/root/.bash_history")")

        # process mounts
        for arg in "$@"; do
            # if argument is a file, then expand it to windows paths
            if [[ "$prev_arg" == '-v' ]]; then
                # docker doesn't support -vPATH:PATH only -v PATH:PATH
                # previous arg was a volume indicator
                dir="$(echo "${arg}" | cut -d':' -f1)"
                if [[ -e "$dir" && "$(realpath "${dir}")" =~ ^/[a-z]/ && "$dir" != /tmp* ]]; then
                    map="$(echo "${arg}" | cut -d':' -f2)"
                    res="/mnt/hgfs$(realpath "${dir}")"
                    if [[ -n "$map" && "$arg" =~ : ]]; then
                        res="${res}:${map}"
                    else
                        res="${res}:$(realpath "${dir}")"
                    fi
                else
                    res="${arg}"
                fi
                args=("${args[@]}" "$(printf '%q' "${res}")")
            else
                # append
                args=("${args[@]}" "$arg")
            fi
            prev_arg="$arg"
        done
        # send the remapped volume paths
        docker-ssh docker "$SHELL_DOCKER_ACTION" "${args[@]}"
        docker-refresh-port-forwards
    ;;
    start|stop|kill)
        docker-startup
        docker-refresh-port-forwards
        docker-ssh docker "$SHELL_DOCKER_ACTION" "$@"
        docker-refresh-port-forwards
    ;;
    build|cp)
        docker-startup
        # always try to change the working directory to $PWD
        docker-ssh cd $(printf '%q' "/mnt/hgfs$(realpath "$(pwd)")") \&\>/dev/null \; docker "$SHELL_DOCKER_ACTION" "$@"
    ;;
    compose)
        docker-startup
        # remap working dir
        # alias docker-compose="docker compose"
        WORKDIR="/mnt/hgfs$(realpath "$(pwd)")"
        docker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock -v "$(pwd)":"${WORKDIR}" -w "${WORKDIR}" docker/compose:$LATEST_DOCKER_COMPOSE_TAG "$@"
    ;;
    *)
        docker-startup
        # default run docker command on remote host
        docker-ssh docker "$SHELL_DOCKER_ACTION" $(docker-escape-args "$@")
    ;;
esac
