#!/bin/bash

SCRIPT="$0"

SSH_OPTIONS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o ConnectTimeout=5"
if [[ "$(uname -m)" == "x86_64" ]]; then
    VMRUN_BIN='C:\Program Files (x86)\VMware\VMware Workstation\vmrun.exe'
    VMFSTOOLS_BIN='C:\Program Files (x86)\VMware\VMware Workstation\vmware-vdiskmanager.exe'
else
    VMRUN_BIN='C:\Program Files\VMware\VMware Workstation\vmrun.exe'
    VMFSTOOLS_BIN='C:\Program Files\VMware\VMware Workstation\vmware-vdiskmanager.exe'
fi
VM_ROOT_DIR="${VM_ROOT_DIR-"$(cygpath --mydocs)/Virtual Machines"}"
VMPATH="$(cygpath -w "$(realpath "${VM_ROOT_DIR}")")"'\boot2docker\boot2docker.vmx'
VMDKPATH="$(cygpath -w "$(realpath "${VM_ROOT_DIR}")")"'\boot2docker\boot2docker.vmdk'
VMDIR="$(dirname "$(cygpath "$VMPATH")")"
LATEST_BOOT2DOCKER_TAG="v17.05.0-ce"
LATEST_DOCKER_COMPOSE_TAG="1.13.0"
DOCKER_USER_PASSWD=tcuser
DOCKER_CONFIG_HOME="$HOME/.docker"

# make the docker home workdir
if [[ ! -d "$DOCKER_CONFIG_HOME" ]]; then
    mkdir -p "$DOCKER_CONFIG_HOME" &>/dev/null
    chmod 700 "$DOCKER_CONFIG_HOME"
fi

function _docker-host () {
    if [[ -n "${DOCKER_HOST}" ]]; then
        echo "${DOCKER_HOST}"
        return 0
    fi
    echo $(_docker-ip)
}

function _docker-ssh () {
    if [[ ! -t 0 && ! -t 1 ]]; then
        # pipe mode
        ssh ${SSH_OPTIONS} docker@$(_docker-host) -- "$@"
    else
        # non pipe mode
        ssh ${SSH_OPTIONS} -t docker@$(_docker-host) -- "$@"
    fi
}

function _docker-ssh-batch-mode () {
    ssh ${SSH_OPTIONS} -o 'Batchmode yes' docker@$(_docker-host) -- "$@"
}

function _docker-escape-args () {
    if [[ $# == 0 ]]; then
        return
    fi
    args=( )
    for arg in "$@"; do
        args=("${args[@]}" $(printf '%q' "$arg"))
    done
    echo "${args[@]}"
}

function _docker-get () {
    local TARGET="$1"
    local DEST="${2-.}"
    scp -r ${SSH_OPTIONS} docker@$(_docker-host):"$TARGET" "$DEST"
}

function _docker-create-vm-vmx () {
    cat <<-EOF
.encoding = "windows-1252"
config.version = "8"
logging = "FALSE"
virtualHW.version = "11"
numvcpus = "2"
cpuid.coresPerSocket = "2"
vcpu.hotadd = "TRUE"
scsi0.present = "TRUE"
scsi0.virtualDev = "lsilogic"
memsize = "2048"
mem.hotadd = "TRUE"
mainMem.save.vmem = "FALSE"
MemTrimRate = "0"
scsi0:0.present = "TRUE"
scsi0:0.fileName = "boot2docker.vmdk"
ide1:0.present = "TRUE"
ide1:0.fileName = "boot2docker.iso"
ide1:0.deviceType = "cdrom-image"
ethernet0.present = "TRUE"
ethernet0.connectionType = "nat"
ethernet0.virtualDev = "e1000"
ethernet0.wakeOnPcktRcv = "FALSE"
ethernet0.addressType = "generated"
ethernet1.present = "TRUE"
ethernet1.connectionType = "hostonly"
ethernet1.wakeOnPcktRcv = "FALSE"
ethernet1.addressType = "generated"
pciBridge0.present = "TRUE"
pciBridge4.present = "TRUE"
pciBridge4.virtualDev = "pcieRootPort"
pciBridge4.functions = "8"
pciBridge5.present = "TRUE"
pciBridge5.virtualDev = "pcieRootPort"
pciBridge5.functions = "8"
pciBridge6.present = "TRUE"
pciBridge6.virtualDev = "pcieRootPort"
pciBridge6.functions = "8"
pciBridge7.present = "TRUE"
pciBridge7.virtualDev = "pcieRootPort"
pciBridge7.functions = "8"
vmci0.present = "TRUE"
hpet0.present = "TRUE"
displayName = "boot2docker"
guestOS = "other26xlinux-64"
nvram = "boot2docker.nvram"
virtualHW.productCompatibility = "hosted"
powerType.powerOff = "soft"
powerType.powerOn = "soft"
powerType.suspend = "soft"
powerType.reset = "soft"
extendedConfigFile = "boot2docker.vmxf"
floppy0.present = "FALSE"
isolation.tools.unity.disable = "TRUE"
unity.allowCompositingInGuest = "FALSE"
unity.enableLaunchMenu = "FALSE"
unity.showBadges = "FALSE"
unity.showBorders = "FALSE"
unity.wasCapable = "FALSE"
sched.mem.pshare.enable = "FALSE"
EOF
}

function _docker-create-vm () {
    # allow differently sized vms
    local VMDK_SIZE="${VMDK_SIZE-16GB}"
    local VMEM_SIZE="${VMEM_SIZE-2048}"

    mkdir -p "${VMDIR}"

    # generate the vmx file
    _docker-create-vm-vmx > "${VMDIR}/boot2docker.vmx"
    # generate the vmdk disk
    ( cd "${VMDIR}"; "$(cygpath -u "$VMFSTOOLS_BIN")" -c -s "${VMDK_SIZE}" -a lsilogic -t 0 boot2docker.vmdk )

    # allow access to all cores
    local PROC_CORES=$(grep "^processor" -c /proc/cpuinfo)
    sed -i 's/numvcpus = "[0-9]"/numvcpus = "'${PROC_CORES}'"/' "${VMDIR}/boot2docker.vmx"
    sed -i 's/cpuid.coresPerSocket = "[0-9]"/cpuid.coresPerSocket = "'${PROC_CORES}'"/' "${VMDIR}/boot2docker.vmx"
    sed -i 's/^memsize = "2048"/memsize = "'${VMEM_SIZE}'"/' "${VMDIR}/boot2docker.vmx"

    # set up shared folders
    local COUNTER drive
    COUNTER=0
    for drive in $(fsutil fsinfo drives | tr -d '\r' | tr ' ' '\n' | tail -n+3 | head -n-1); do
        echo 'sharedFolder'${COUNTER}'.present = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.enabled = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.readAccess = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.writeAccess = "TRUE"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.hostPath = "'${drive}'"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.guestName = "'$(echo "$drive" | cut -d ':' -f 1 | tr '[:upper:]' '[:lower:]')'"' >> "${VMDIR}/boot2docker.vmx"
        echo 'sharedFolder'${COUNTER}'.expiration = "never"' >> "${VMDIR}/boot2docker.vmx"
        (( COUNTER += 1 ))
    done
    echo 'sharedFolder.maxNum = "'${COUNTER}'"' >> "${VMDIR}/boot2docker.vmx"
    echo 'isolation.tools.hgfs.disable = "FALSE"' >> "${VMDIR}/boot2docker.vmx"

    # fix cygwin permissions...
    setfacl -b "${VMDIR}"
    chmod -R 755 "${VMDIR}"
    sleep 2
}

function _docker-destroy-vm () {
    _docker-vmrun stop hard
    rm -rf "$VMDIR"
}

function _docker-vmrun () {
    local VM_CMD=$1
    shift
    "$(cygpath -u "$VMRUN_BIN")" -T ws -gu docker -gp "$DOCKER_USER_PASSWD" "${VM_CMD}" "$(cygpath -w "$VMPATH")" "$@" | tr -d '\r'
}

function _docker-ip () {
    _docker-vmrun getGuestIPAddress -wait
}

function _docker-vmup () {
    _docker-vmrun start nogui
}

function _docker-vmdown () {
    _docker-vmrun stop
}

function _docker-vm-is-on () {
    "$(cygpath -u "$VMRUN_BIN")" list | tr -d '\r' | sed 's/\\/\//g' | grep "$(cygpath -w "$VMPATH" | sed 's/\\/\//g')" 2>&1 >/dev/null
}

function _docker-reboot () {
    _docker-ssh sudo reboot
}

function _docker-startup () {
    if ! _docker-vm-is-on; then
        _docker-vmup
        _docker-vm-wait-for-tools
    fi
}

function _docker-boot2docker-iso-url () {
    echo "https://github.com/boot2docker/boot2docker/releases/download/${LATEST_BOOT2DOCKER_TAG}/boot2docker.iso"
}

function _docker-download-iso () {
    local ISO_URL="$(_docker-boot2docker-iso-url)"
    local ISO_PATH="$VMDIR/boot2docker.iso"
    if [[ -z "${ISO_URL}" ]]; then
        return 1
    fi

    # use cached copy
    if [[ -e "${DOCKER_CONFIG_HOME}/boot2docker-${LATEST_BOOT2DOCKER_TAG}.iso" ]]; then
        rm -f "$ISO_PATH" || true
        cp "${DOCKER_CONFIG_HOME}/boot2docker-${LATEST_BOOT2DOCKER_TAG}.iso" "$ISO_PATH"
        return 0
    fi

    curl -L# "$ISO_URL" > "$ISO_PATH.new"
    if [[ $? == 0 ]]; then
        rm -f "$ISO_PATH" || true
        mv "$ISO_PATH.new" "${DOCKER_CONFIG_HOME}/boot2docker-${LATEST_BOOT2DOCKER_TAG}.iso"
        cp "${DOCKER_CONFIG_HOME}/boot2docker-${LATEST_BOOT2DOCKER_TAG}.iso" "$ISO_PATH"
    else
        echo "Failed to download!"
        return 1
    fi
}

_docker-vm-wait-for-tools () {
    local COUNTER=0
    while ( ! _docker-vmrun checkToolsState 2>&1 | grep 'running\|installed' &>/dev/null ) && [[ $COUNTER -lt 20 ]]; do
        sleep 15
        COUNTER=$((COUNTER+1))
    done
}

function _docker-vm-init () {
    # http://odewahn.github.io/docker-jumpstart/boot2docker.html
    # http://blog.gnu-designs.com/howto-run-boot2docker-in-vmware-fusion-and-esxi-with-shipyard-to-manage-your-containers/

    local ID_RSA_PUB="$(cat ~/.ssh/id_rsa.pub)"

    if _docker-vmrun checkToolsState | grep 'running\|installed' &>/dev/null; then
        # try to push ssh keys through vmware guest tools
        _docker-vmrun runScriptInGuest /bin/sh "\
            sudo chown docker -R /home/docker/.ssh; \
            mkdir /home/docker/.ssh || true; \
            chmod 700 /home/docker/.ssh || true; \
            chmod 600 /home/docker/.ssh/authorized_keys; \
            cat /home/docker/.ssh/authorized_keys | grep \"${ID_RSA_PUB}\" || echo \"${ID_RSA_PUB}\" >> /home/docker/.ssh/authorized_keys; \
            sudo chown docker -R /home/docker/.ssh; \
            "
    else
        echo "Default password is '$DOCKER_USER_PASSWD'"
    fi

_docker-ssh << DOCKER_INIT
#!/bin/sh

if ! blkid -c /dev/null | grep boot2docker-data &>/dev/null; then
    echo -e "\033[0;32mFormatting /dev/sda\033[0m"

    echo -ne "\033[0;34m"
    echo -e "n\np\n1\n\n\nw\n" | sudo fdisk /dev/sda
    sudo mkfs.ext4 -L boot2docker-data /dev/sda1
    sudo mkdir /mnt/sda1
    sudo mount -t ext4 /dev/sda1 /mnt/sda1
    sudo mkdir -p /mnt/sda1/var/lib/boot2docker
    echo -ne "\033[0m"
fi

TCL_REPO_BASE=http://tinycorelinux.net/6.x/x86_64
WORKING_DIR="\$(pwd)"
BUILD_DIR="/tczbuild"
sudo mkdir "\$BUILD_DIR"

echo -e "\033[0;32mBuilding userdata.tar\033[0m"

echo -ne "\033[0;34m"
mkdir -p /home/docker/.ssh
sudo chown docker -R /home/docker/.ssh
chmod 700 /home/docker/.ssh
touch /home/docker/.ssh/authorized_keys
sudo touch /mnt/sda1/var/lib/boot2docker/.ash_history
sudo chown docker /mnt/sda1/var/lib/boot2docker/.ash_history
chmod 600 /home/docker/.ssh/authorized_keys
cat /home/docker/.ssh/authorized_keys | grep "${ID_RSA_PUB}" || echo "${ID_RSA_PUB}" >> /home/docker/.ssh/authorized_keys
cd /home/docker

# write history options
# Don't put duplicate lines in the history.
echo "export HISTCONTROL=\\\$HISTCONTROL\\\${HISTCONTROL+,}ignoredups" >> /home/docker/.profile
# Ignore some controlling instructions: exit, ls, empty cd, pwd, date, help pages
echo "export HISTIGNORE=\\\$'[ \t]*:&:[fb]g:exit:ls:ls -?::ls -??:ll:history:cd:cd -:cd ~:cd ..:..:pwd:date:* --help'" >> /home/docker/.profile
# Larger bash history (allow 32³ entries; default is 500)
echo "export HISTSIZE=32768" >> /home/docker/.profile
echo "export HISTFILESIZE=32768" >> /home/docker/.profile

ln -sf /var/lib/boot2docker/.ash_history .ash_history
sudo tar -vcf /mnt/sda1/var/lib/boot2docker/userdata.tar .ssh .ash_history .profile
cd "\$WORKING_DIR"
echo -ne "\033[0m"

echo -e "\033[0;32mInstalling local boot script and profile\033[0m"

echo -e "\033[0;34m"

sudo tee /mnt/sda1/var/lib/boot2docker/bootlocal.sh << BOOT2DOCKER_INIT_SCRIPT
#!/bin/sh

echo > /var/lib/boot2docker/docker.log

BOOT2DOCKER_INIT_SCRIPT

sudo chmod 755 /mnt/sda1/var/lib/boot2docker/bootlocal.sh

sudo tee /mnt/sda1/var/lib/boot2docker/profile << BOOT2DOCKER_PROFILE_SCRIPT
#!/bin/sh

EXTRA_ARGS="--insecure-registry localhost"

BOOT2DOCKER_PROFILE_SCRIPT

sudo chmod 755 /mnt/sda1/var/lib/boot2docker/profile

# force regenerating the docker tls certs
sudo rm -rf /home/docker/.docker
sudo rm -rf /var/lib/boot2docker/tls

echo -e "\033[0m"

echo -e "\033[0;32mRebooting\033[0m"
sudo reboot

DOCKER_INIT
    sleep 20
    _docker-vm-wait-for-tools

    echo -e "\033[0;32mPulling ssl certs\033[0m\033[0;34m"
    _docker-get '~/.docker/*' "${DOCKER_CONFIG_HOME}/"
    touch "${DOCKER_CONFIG_HOME}/.docker_history"
    echo -ne "\033[0m"

    echo -e "\033[0;32mReady\033[0m"
}

function _docker-vm-clean () {
    echo -ne "\033[0;32m"
    echo "Cleaning ALL up docker images"
    echo -ne "\033[0m\033[0;34m"
    if [[ $1 == "-a" ]]; then
        _docker-ssh docker rm $(_docker-ssh docker ps -a -q)
    fi
    _docker-ssh docker rmi $(_docker-ssh docker images | grep "^<none>" | awk '{print $3}')
    echo -ne "\033[0m\033[0;32m"
    echo "Shrinking disk"
    echo -ne "\033[0m\033[0;34m"
    VMDK_SIZE_OLD=$(du -hs "$(cygpath -u "$VMDKPATH")" | awk '{print $1}')
    _docker-ssh sudo vmware-toolbox-cmd disk shrink /mnt/sda1
    VMDK_SIZE_NEW=$(du -hs "$(cygpath -u "$VMDKPATH")" | awk '{print $1}')
    echo -ne "\033[0m"
    echo -e "\033[0;32mOld Size: \033[1;32m${VMDK_SIZE_OLD}\033[0m"
    echo -ne "\033[0m"
    echo -e "\033[0;32mNew Size: \033[1;32m${VMDK_SIZE_NEW}\033[0m"
    echo -ne "\033[0m"
}

function _docker-ps1 () {
    local PS1_COLOR_RESET='\[\e[0m\]'
    local PS1_COLOR_EXIT_ERROR='\[\e[38;5;196m\]'
    local PS1_COLOR_USER='\[\e[38;5;197m\]'
    local PS1_COLOR_HOST='\[\e[38;5;208m\]'
    local PS1_COLOR_HOST_SCREEN='\[\e[4m\]\[\e[38;5;214m\]'
    local PS1_COLOR_WORK_DIR='\[\e[38;5;142m\]'

    local PS1_EXIT_STATUS='$(EXIT="$?"; [[ $EXIT -ne 0 ]] && echo -n "(E:${EXIT}) ")'

    echo "[${PS1_COLOR_EXIT_ERROR}${PS1_EXIT_STATUS}${PS1_COLOR_RESET}${PS1_COLOR_USER}\u${PS1_COLOR_RESET}@${PS1_COLOR_HOST_SCREEN}docker${PS1_COLOR_RESET}.${PS1_COLOR_HOST}\h${PS1_COLOR_RESET} ${PS1_COLOR_WORK_DIR}\W${PS1_COLOR_RESET}]$(echo -e "\xE2\x99\xAB") "
}

# ======================================================================================================================
# Start of commnds
# ======================================================================================================================

SHELL_DOCKER_ACTION="$1"
shift
case "$SHELL_DOCKER_ACTION" in
    ssh)
        _docker-ssh "$@"
    ;;
    ssh-batch)
        _docker-ssh-batch-mode "$@"
    ;;
    curl)
        curl --insecure --cert "${DOCKER_CONFIG_HOME}/cert.pem" --key "${DOCKER_CONFIG_HOME}/key.pem" "$@"
    ;;
    vm)
        SHELL_DOCKER_SUBACTION="$1"
        shift
        case "$SHELL_DOCKER_SUBACTION" in
            build)
                _docker-create-vm
                _docker-download-iso
                _docker-vmup
                _docker-vm-wait-for-tools
                _docker-vm-init
            ;;
            clean)
                _docker-vm-clean
            ;;
            confdir)
                echo "$DOCKER_CONFIG_HOME"
            ;;
            create)
                echo -ne "\033[0;34m"
                _docker-create-vm
                _docker-download-iso
                echo -ne "\033[0m"
            ;;
            destroy)
                _docker-destroy-vm
            ;;
            download)
                _docker-download-iso
            ;;
            htop)
                _docker-ssh docker run -it --rm --pid=host jess/htop htop "$@"
            ;;
            init)
                _docker-vm-init
            ;;
            poweroff)
                _docker-vmrun stop hard
            ;;
            reboot)
                _docker-reboot
                sleep 20
                _docker-vm-wait-for-tools
            ;;
            rebuild)
                docker vm destroy
                docker vm build
            ;;
            run)
                _docker-vmrun "$@"
            ;;
            *)
                exit 1
            ;;
        esac
    ;;
    ip)
        _docker-ip
    ;;
    up)
        _docker-vmup
        _docker-vm-wait-for-tools
    ;;
    down)
        _docker-vmdown
    ;;
    help)
        _docker-ssh docker help "$@"
        if [[ $# == 0 ]]; then
            echo
            echo 'Additional options for windows docker script:'
            echo
            echo '    curl      Make a curl request against the docker api, use https://localhost:2376/'
            echo '    down      Stop the boot2docker vm'
            echo '    ip        Get the ip of the boot2docker vm'
            echo '    ssh       SSH into docker server or run remote commands'
            echo '    up        Start the boot2docker vm'
            echo '    vm        Execute actions against the virtual machine, subactions:'
            echo '    ├ build       Create and initialize the boot2docker vm'
            echo '    ├ clean       Remove unused docker images and containers. Use -a to remove stopped containers'
            echo '    ├ create      Create the boot2docker vm'
            echo '    ├ destroy     Destroy the boot2docker vm'
            echo '    ├ download    Download the latest boot2docker.iso'
            echo '    ├ htop        Run htop in the boot2docker vm'
            echo '    ├ init        Initialize the boot2docker vm'
            echo '    ├ poweroff    Power off the boot2docker vm'
            echo '    ├ reboot      Reboot the boot2docker vm'
            echo '    ├ rebuild     Recreate and initialize the boot2docker vm'
            echo '    └ run         Run a vmware command against boot2docker vm'
        fi
    ;;
    run)
        _docker-startup
        args=( )
        prev_arg=

        # generate a persistient history file
        args=("${args[@]}" "-e" "HISTFILE=/root/.bash_history")
        args=("${args[@]}" "-e" "$(printf '%q' "HISTIGNORE=${HISTIGNORE}")")
        args=("${args[@]}" "-e" "$(printf '%q' "HISTCONTROL=${HISTCONTROL}")")
        args=("${args[@]}" "-e" "HISTSIZE=${HISTSIZE}")
        args=("${args[@]}" "-e" "HISTFILESIZE=${HISTFILESIZE}")
        args=("${args[@]}" "-e" "$(printf '%q' "PROMPT_COMMAND=history -a")")
        args=("${args[@]}" "-e" "$(printf '%q' "PS1=$(_docker-ps1)")")
        args=("${args[@]}" "-e" "$(printf '%q' "PS2=$(echo -e "\xe2\x86\x92") ")")
        args=("${args[@]}" "-v" "$(printf '%q' "/mnt/hgfs$(realpath "$HOME")/.docker/.docker_history:/root/.bash_history")")

        # process mounts
        for arg in "$@"; do
            # if argument is a file, then expand it to windows paths
            if [[ "$prev_arg" == '-v' ]]; then
                # docker doesn't support -vPATH:PATH only -v PATH:PATH
                # previous arg was a volume indicator
                dir="$(echo "${arg}" | cut -d':' -f1)"
                if [[ -e "$dir" && "$(realpath "${dir}")" =~ ^/[a-z]/ && "$dir" != /tmp* ]]; then
                    map="$(echo "${arg}" | cut -d':' -f2)"
                    res="/mnt/hgfs$(realpath "${dir}")"
                    if [[ -n "$map" && "$arg" =~ : ]]; then
                        res="${res}:${map}"
                    else
                        res="${res}:$(realpath "${dir}")"
                    fi
                else
                    res="${arg}"
                fi
                args=("${args[@]}" "$(printf '%q' "${res}")")
            else
                # append
                args=("${args[@]}" "$arg")
            fi
            prev_arg="$arg"
        done
        # send the remapped volume paths
        _docker-ssh docker "$SHELL_DOCKER_ACTION" "${args[@]}"
    ;;
    start|stop|kill)
        _docker-startup
        _docker-ssh docker "$SHELL_DOCKER_ACTION" "$@"
    ;;
    build|cp)
        _docker-startup
        # always try to change the working directory to $PWD
        _docker-ssh cd $(printf '%q' "/mnt/hgfs$(realpath "$(pwd)")") \&\>/dev/null \; docker "$SHELL_DOCKER_ACTION" "$@"
    ;;
    compose)
        _docker-startup
        # remap working dir
        # alias docker-compose="docker compose"
        WORKDIR="/mnt/hgfs$(realpath "$(pwd)")"
        docker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock -v "$(pwd)":"${WORKDIR}" -w "${WORKDIR}" docker/compose:$LATEST_DOCKER_COMPOSE_TAG "$@"
    ;;
    *)
        _docker-startup

        # run plugin architecture command instead
        if type "docker-$SHELL_DOCKER_ACTION" &>/dev/null; then
            "docker-$SHELL_DOCKER_ACTION" "$@"
        else
            # default run docker command on remote host
            _docker-ssh docker "$SHELL_DOCKER_ACTION" $(_docker-escape-args "$@")
        fi
    ;;
esac
